<?
	namespace eval cache {}

if {[catch {

	unset -nocomplain args
	unset -nocomplain module

	if {![info exists ::auto_path_set]} {
		set ::auto_path_set 1
		lappend auto_path local/packages packages
	}

	if {![info exists ::done_onlyonce_dbconfig]} {
		if {[file exists modules/autoload/onlyonce/dbconfig.tcl]} {
			source modules/autoload/onlyonce/dbconfig.tcl
		}
		if {[file exists local/modules/autoload/onlyonce/dbconfig.tcl]} {
			source local/modules/autoload/onlyonce/dbconfig.tcl
		}
		set ::done_onlyonce_dbconfig 1
	}

	if {![info exists ::done_onlyonce]} {
		package require module
		package require debug
		package require web
		package require user

		foreach file [glob -nocomplain modules/*/load/*.tcl modules/load/onlyonce/*.tcl modules/autoload/onlyonce/*.tcl local/modules/*/load/*.tcl local/modules/load/onlyonce/*.tcl local/modules/autoload/onlyonce/*.tcl] {
			debug::log index.rvt "source $file"
			namespace eval :: "source $file"
		}
		set ::done_onlyonce 1
	}

	load_response args
	load_headers

	if {[info exists args(module)]} {
		set module $args(module)
	} else {
		set module main
	}

	set state INIT
	foreach file [glob -nocomplain modules/load/*.tcl modules/autoload/*.tcl local/modules/load/*.tcl local/modules/autoload/*.tcl] {
		debug::log index.rvt "source $file"
		source $file
	}

	# Go no further without a UID.
	if {[user::getuid] == 0} {
		set module "login"
	}

	# Do the header and footer init stuff only once.
	if {![info exists ::finimods]} {
		set ::finimods ""
		foreach initmod [lsort -dictionary $::initmods] {
			if {[string match "*:*" $initmod]} {
				set initmod [join [lrange [split $initmod :] 1 end] :]
			}
			set modpage [module::call $initmod start]
			if {$modpage == ""} {
				continue
			}
			lappend ::headers $initmod $modpage
			set ::finimods [linsert $::finimods 0 $initmod]
		}
		foreach finimod $::finimods {
			set modpage [module::call $finimod stop]
			if {$modpage == ""} {
				continue
			}
			lappend ::footers $finimod $modpage
		}
	}

	set subaction ""
	foreach var [array names args] {
		if {[string match "*.y" $var]} {
			continue
		}
		if {[string match "*.x" $var]} {
			set basevar [string range $var 0 end-2]
			if {![info exists ::request::args($basevar.y)]} {
				continue
			}
			set ::request::args($basevar) [list $::request::args($basevar.x) $::request::args($basevar.y)]
			unset ::request::args($basevar.x) ::request::args($basevar.y)
			set var "$basevar"
		}
		if {[string match "subaction_*" $var]} {
			set subaction [string tolower [join [lrange [split $var _] 1 end] _]]
			break
		}
		if {[string tolower $var] == "subaction"} {
			set subaction [join [split [string tolower $args($var)]] _]
			break
		}
	}

	if {[info exists args(action)]} {
		set newpage [module::call $module $args(action) $subaction]
	} else {
		set newpage [module::call $module "" $subaction]
	}

	# Assume a blank return value means
	# that the user is required to authenticate?
	if {$newpage == ""} {
		set module "login"
		set newpage [module::call login "" ""]
	}

	foreach {headmod header} $::headers {
		debug::log index.rvt "Displaying $header/$headmod"
		display $header $headmod
	}
	display $newpage $module
	foreach {footmod footer} $::footers {
		debug::log index.rvt "Displaying $footer/$footmod"
		display $footer $footmod
	}

	set state TERM
	foreach file [glob -nocomplain modules/unload/*.tcl local/modules/unload/*.tcl modules/autoload/*.tcl local/modules/autoload/*.tcl] {
		source $file
	}
} errmsg]} {
	set savedtrace $errorInfo

	# Throw the error again if there's an error handler
	if {[namespace which -command rivet_error] != ""} {
		error $errmsg $errorInfo
	} else {
		# Otherwise, handle it ourselves.
		puts "<HTML>"
		puts "  <HEAD><TITLE>ERROR</TITLE></HEAD>"
		puts "  <BODY>"
		puts "    <PRE>"
		puts "ERROR:"
		puts "$errmsg"
		puts "    </PRE>"
		puts "  </BODY>"
		puts "</HTML>"
	}
}

	namespace delete cache
?>
