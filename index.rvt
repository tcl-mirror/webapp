<?

namespace eval cache {}

if {[catch {
	# Clean up from previous run, if needed
	unset -nocomplain args
	unset -nocomplain module

	# If this interpreter (not request) has not already been globally initialized, initialize it now
	## Update the global auto_path if not already done
	if {![info exists ::auto_path_set]} {
		set ::auto_path_set 1
		lappend auto_path local/packages packages
	}

	## Load the database configuration if not already done
	if {![info exists ::done_onlyonce_dbconfig]} {
		if {[file exists modules/load/onlyonce/dbconfig.tcl]} {
			source modules/load/onlyonce/dbconfig.tcl
		}
		if {[file exists local/modules/load/onlyonce/dbconfig.tcl]} {
			source local/modules/load/onlyonce/dbconfig.tcl
		}
		set ::done_onlyonce_dbconfig 1
	}

	## Load scripts that get loaded for every interpreter
	if {![info exists ::done_onlyonce]} {
		package require module
		package require debug
		package require web
		package require user

		foreach file [glob -nocomplain local/modules/*/preload/*.tcl modules/*/load/*.tcl modules/load/onlyonce/*.tcl local/modules/*/load/*.tcl local/modules/load/onlyonce/*.tcl] {
			debug::log index.rvt "source $file"

			namespace eval :: "source $file"
		}
		set ::done_onlyonce 1
	}

	# Load this requests environment
	load_response args
	load_headers
	load_env

	# If a module was specified in the request, use it ...
	if {[info exists args(module)]} {
		set module $args(module)
	} else {
		#a... otherwise use the "defaultmodule" global variable. 
		if {[info exists ::defaultmodule]} {
			set module $::defaultmodule
		} else {
			## ... failing that use the module named "main"
			set module main
		}
	}

	# Load scripts that get run with every request
	foreach file [glob -nocomplain local/modules/preload/*.tcl modules/load/*.tcl local/modules/load/*.tcl] {
		debug::log index.rvt "source $file"
		source $file
	}

	# If we are not someone (anonymous is someone...) make the user authenticate using the "login" module
	if {[user::getuid] == 0} {
		set module "login"
	}

	# Determine and call initialization modules specified by the "initmods" global variable
	# for this request
	## This variable may contain a sorting prefix in the form of <prefix>:<module>
	## This prefix is ignored, but used for sorting.
	## The action called for the module is called "start" (for initialization) and "stop" for
	## deinitialization of this request
	if {![info exists ::finimods]} {
		set ::finimods ""
		foreach initmod [lsort -dictionary $::initmods] {
			if {[string match "*:*" $initmod]} {
				set initmod [join [lrange [split $initmod :] 1 end] :]
			}
			set modpage [module::call $initmod start]
			if {$modpage == ""} {
				continue
			}
			lappend ::headers $initmod $modpage
			set ::finimods [linsert $::finimods 0 $initmod]
		}
		foreach finimod $::finimods {
			set modpage [module::call $finimod stop]
			if {$modpage == ""} {
				continue
			}
			lappend ::footers $finimod $modpage
		}
	}

	# Convert image arguments into simple lists
	foreach var [array names args] {
		if {[string match "*.y" $var]} {
			continue
		}
		if {[string match "*.x" $var]} {
			set basevar [string range $var 0 end-2]
			if {![info exists ::request::args($basevar.y)]} {
				continue
			}
			set ::request::args($basevar) [list $::request::args($basevar.x) $::request::args($basevar.y)]
			unset ::request::args($basevar.x) ::request::args($basevar.y)
			set var "$basevar"
		}
	}

	# Determine subaction
	set subaction ""
	foreach var [array names args] {
		if {[string match "subaction_*" $var]} {
			set subaction [string tolower [join [lrange [split $var _] 1 end] _]]
			break
		}
		if {[string tolower $var] == "subaction"} {
			set subaction [join [split [string tolower $args($var)]] _]
			break
		}
	}

	# Determine action method to call for this module, and invoke the module
	## It should return a page name to display to the user
	if {[info exists args(action)]} {
		debug::log index.rvt [list module::call $module $args(action) $subaction]

		set newpage [module::call $module $args(action) $subaction]
	} else {
		debug::log index.rvt [list module::call $module "" $subaction]

		set newpage [module::call $module "" $subaction]
	}

	# Assume a blank return value means
	# that the user is required to authenticate?
	if {$newpage == ""} {
		set module "login"

		set newpage [module::call login "" ""]
	}

	# Display the header output as determined earlier for this interpreter
	if {![info exists args(_webapp_noheader)]} {
		foreach {headmod header} $::headers {
			debug::log index.rvt "Displaying $header/$headmod"
			display $header $headmod
		}
	}

	# Display the actual page
	display $newpage $module

	# Display the footer output
	if {![info exists args(_webapp_noheader)]} {
		foreach {footmod footer} $::footers {
			debug::log index.rvt "Displaying $footer/$footmod"
			display $footer $footmod
		}
	}

	# Load scripts that get run at the end of every request
	foreach file [glob -nocomplain modules/unload/*.tcl local/modules/unload/*.tcl] {
		source $file
	}
} errmsg]} {
	set savedtrace $::errorInfo

	set failed 1
} else {
	set failed 0
}

catch {
	namespace delete cache
}

catch {
	update idletasks
}

if {$failed} {
	# Throw the error again if there's an error handler
	if {[namespace which -command rivet_error] != ""} {
		error $errmsg $savedtrace
	} else {
		# Otherwise, handle it ourselves.
		puts "<HTML>"
		puts "  <HEAD><TITLE>ERROR</TITLE></HEAD>"
		puts "  <BODY>"
		puts "    <PRE>"
		puts "ERROR:"
		puts "$errmsg"
		puts "    </PRE>"
		puts "  </BODY>"
		puts "</HTML>"
	}
}

?>
